- [x] implement library as currently documented
- [x] support dynamic children
- [x] break out classes into separate files
- [x] add support for dynamic values that depend on multiple states
- [x] fix circular dependencies
- [x] fix the FIXME
- [x] eliminate the clunky ".dynamicValue" pattern
  - one way to do this would be to allow the state object itself to be passed in and have dynamicValue be called behind the scenes however this wouldn't account for modifier functions or multistate dynamic values
  - another strategy could be to have state objects be functions which could then take a modifier function and there may be a way to effectively build up multistate dynamic values using modifer functions that have access to other state objects via closure
  - another option is to simply have a utility function (perhaps with a name like `dv`) that takes either a state or a object combining multiples states and an option modifier function and have that patter be used everywhere
  - another since we will already be compiling JSX is to create a new syntax using `@` that gets compiled to one of the above options
- [x] fix support for strings within dynamic values in a child context the issue is that we are calling #after on a text node and passing it an Entity. We need to define a new #replace method on the DynamicEntity that takes a before and an after and behaves differently depending on types
- [x] make fragments work properly
- [x] eliminitate the circular dependency using lazy binding and avoid isX properties
- [x] add a push method to State that only works if the value is an array (and maybe like an update method for objects..)
- [x] consider exporting dynamicValue as dv to avoid encouraging an awkward destructuring
- [x] would it be more user friendly to automatically interpret state objects as single state dynamic values so that <p>{stateObject}<p> would work intuitively (more react like in syntax)? I think we keep the dynamic value function for cases where we want a function over the state but maybe we just spell it out as `dynamicValue` in our examples (and leave shortenings like dv up to developer taste)
- [x] bringing back the circular dependency to avoid the lazy binding pattern and suppress the warnings
- [x] streamline build process so that the package can be installed and used easily
- [ ] add built in cutom entities to handle standard inputs so that users dont have to type `onChange={(e) => state.set(e.target.value)}` every time':
- [ ] create some standard entities like:
  ```jsx
  const value = new State('foo')
  $container.append(
    <Input type="text" state={value} />
  );
  ```
- [ ] consider aliasing class to className so that people can intuitively say <span class="foo"> giving a competitive advantage over React..
- [ ] improve examples
  - [ ] move most of the examples to JSX
  - [ ] restyle the demo (maybe rename it to be the documentation)
    - introduce a static jsx example first.
    - then introduce state objects
    - and then show how they integrate with interpolation using dv()
    - listeners are a footnote
    - go into a bunch of examples

  - [ ] work on presenting the idea well (text, ordering of things..)
- [ ] Add in-code documentation for all classess, methods, and utility functions
  - [x] classes
  - [ ] utitity functions
- [ ] build comprehensive documentation
  - [ ] explain the concept with comparison to react
  - [ ] add comments to example code
- [x] write tests (ideally the year suite builds everything and then does a browser simulation of the demo/docs)
  - [x] basic JSDOM framework
  - [ ] test all the corner cases we can think of (go through each file and consider coverage manually)
  - [ ] consider browser testing
- [ ] listener management add/remove (consider garbage collection some day)
- [ ] resolve `TODO`s and `Question`s in code
- [ ] add support for DVs that return plain objects (Use TDD for this)
  - e.g.:
    ```
    <p style={
      dv(theme, (t) => {
        if (t === 'light') {
	  return { backgroundColor: '#222', color: '#fff' };
	}
	return { backgroundColor: '#fff', color: '#333' };
      })
    }>lorem ipsum</p>
    ```
  - [x] move `assign` out of Entity.js and into utils.js (this will mess up the dependencies so we will need to add an `isDocuDynamicValue` property to all DynamicValue objects like we did with isDocuEntity)
  - [x] rename it to `assignProperties`
  - [ ] in DynamicValue.js in both the `bindProperty` and `onChange` methods check whether the value isPlainObject and call assignProperties if it is.
- [x] integrate jsx
- [x] create a framework for custom entities (like components but less prescriptive)
  - a component is a function that returns an entity
- [ ] Question: what would happen if a dv was stored in a variable which was then interpolated into the JSX in multiple places.. I think it would work fine with #bindProperty being called twice and thus calling listen multiple times.. I feel like it might also work ok with DynamicEntity simply making separate DynamicEntities to track separate elements.. it might just be fine.. I should test it tho.. i think this would work if the dynamic entity was the result of a dynamic value function returning an entity but if the state is an entity I think we run into trouble.. we should certainly test all cases and maybe we want to log a warning if the user tries to put a single entity in multiple places.. like "Warning: interpolating an entity directly into multiple places will result in it only appearing in the most recent one. If you want multiple copies consider wrapping the interpolation in a dynamic value call: `<div>{dynamicValue({}, () => entity)}</div>`.


- [ ] some day test that treeshaking works right
